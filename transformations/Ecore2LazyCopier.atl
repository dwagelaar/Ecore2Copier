-- @atlcompiler emftvm
-- @nsURI ECORE=http://www.eclipse.org/emf/2002/Ecore
-- @nsURI ATL=http://www.eclipse.org/gmt/2005/ATL
module Ecore2LazyCopier;
create OUT : ATL from IN : ECORE;

--- Returns the root EPackage of the input model (i.e. the EPackage without a super-package).
helper def : rootPackage : ECORE!EPackage =
	ECORE!EPackage.allInstances()
		->any(p | p.eSuperPackage.oclIsUndefined());

helper context ECORE!EPackage def : allEClasses : OrderedSet(ECORE!EClass) =
	self.allEClasses(Set{});

helper context ECORE!EPackage def : allEClasses(collectedPackages : Set(ECORE!EPackage)) : OrderedSet(ECORE!EClass) =
	let newCollectedPackages : Set(ECORE!EClass) = collectedPackages
		->including(self)->union(self.eSubpackages->asSet()) in
	self.eClassifiers
		->select(c | c.includeClass)
		->collect(c | c.allEClasses(newCollectedPackages))
		->flatten()
		->asOrderedSet()
	->union(self.eSubpackages
		->collect(p | p.allEClasses(newCollectedPackages))
		->flatten()
		->asOrderedSet()
	)->sortedBy(c | c.name);

helper context ECORE!EClass def : allEClasses : OrderedSet(ECORE!EClass) =
	self.allEClasses(Set{});

helper context ECORE!EClass def : allEClasses(collectedPackages : Set(ECORE!EPackage)) : OrderedSet(ECORE!EClass) =
	let newCollectedPackages : Set(ECORE!EClass) = collectedPackages
		->including(self.ePackage) in
	let superTypePackages : Set(ECORE!EPackage) = self.eSuperTypes
		->select(t | t.includeClass and newCollectedPackages->excludes(t.ePackage))
		->collect(t | t.ePackage)
		->asSet() in
	let referenceTypePackages : Set(ECORE!EPackage) = self.eReferences
		->collect(r | r.eType)
		->select(t | t.includeClass and newCollectedPackages->excludes(t.ePackage))
		->collect(t | t.ePackage)
		->asSet() in
	superTypePackages
		->collect(c | c.allEClasses(newCollectedPackages))
		->flatten()
		->asOrderedSet()
	->union(referenceTypePackages
		->collect(c | c.allEClasses(newCollectedPackages))
		->flatten()
		->asOrderedSet())
	->including(self);

--- Converts the first character to uppercase.
helper context String def : firstToUpper : String =
	if self.size() > 1 then
		self.substring(1, 1).toUpper() + self.substring(2, self.size())
	else
		self.toUpper()
	endif;

--- Returns whether this EStructuralFeature can/should be assigned to.
helper context ECORE!EStructuralFeature def : assignable : Boolean =
	not (self."derived" or self.transient) and self.changeable;

--- Returns whether this EStructuralFeature can/should be assigned to.
helper context ECORE!EReference def : assignable : Boolean =
	super.assignable and not self.container and self.eType.includeClass;

--- Returns the fully qualified name (e.g. 'package::Class').
helper context ECORE!EClassifier def : qName : String =
	if self.ePackage.oclIsUndefined() then
		self.name
	else
		self.ePackage.qName + '::' + self.name
	endif;

--- Returns the fully qualified name (e.g. 'package::Class').
helper context ECORE!EPackage def : qName : String =
	if self.eSuperPackage.oclIsUndefined() then
		self.name
	else
		self.eSuperPackage.qName + '::' + self.name
endif;

--- Returns the Map of EClasses by name.
helper def : classesByNames : Map(String, Set(ECORE!EClass)) =
	thisModule.rootPackage.allEClasses
		->mappedBy(c | c.name);

--- Returns the unique name for self.
helper context ECORE!EClass def : uniqueName : String =
	if thisModule.classesByNames.get(self.name)->size() > 1 then
		self.qName
	else
		self.name
	endif;

--- Returns False.
helper context OclAny def : includeClass : Boolean =
	false;

--- Returns True if self must be included in the copy rules.
helper context ECORE!EClass def : includeClass : Boolean =
	self <> ECORE!EObject and
	self <> ECORE!EGenericType;

rule RootPackage2Module {
	from
		s : ECORE!EPackage (
			s = thisModule.rootPackage
		)
	to
		t : ATL!Module (
			commentsBefore <- Sequence{
					'-- @atlcompiler emftvm',
					'-- @nsURI ' + s.name.toUpper() + '=' + s.nsURI,
					'-- Generated by Ecore2Copier.atl'
				},
			name <- s.name.firstToUpper + 'LazyCopy',
			inModels <- Sequence{inModel},
			outModels <- Sequence{outModel},
			elements <- s.allEClasses->collect(c | thisModule.EClass2Rule(c))
		),
		metaModel : ATL!OclModel (
			name <- s.name.toUpper()
		),
		inModel : ATL!OclModel (
			name <- 'IN',
			metamodel <- metaModel
		),
		outModel : ATL!OclModel (
			name <- 'OUT',
			metamodel <- metaModel
		)
}

unique lazy rule EClass2Rule {
	from
		s : ECORE!EClass
	to
		t : ATL!LazyMatchedRule (
			commentsBefore <- 
				if s.eSuperTypes->isEmpty() then
					Sequence{}
				else
					Sequence{
						'-- @extends ' + 
						s.eSuperTypes
							->select(st | st.includeClass)
							->collect(st | st.uniqueName.replaceAll('::', '_'))
							->iterate(n; acc: String = '' |
								if acc.size() = 0 then n else acc + ', ' + n endif)
					}
				endif,
			name <- s.uniqueName.replaceAll('::', '_'),
			isAbstract <- s."abstract",
			isUnique <- true,
			inPattern <- inPattern,
			outPattern <- outPattern
		),
		inPattern : ATL!InPattern (
			elements <- Sequence{inElement}
		),
		outPattern : ATL!OutPattern (
			elements <- Sequence{outElement}
		),
		inElement : ATL!SimpleInPatternElement (
			varName <- 's',
			type <- thisModule.EClass2OclModelElement(s)
		),
		outElement : ATL!SimpleOutPatternElement (
			varName <- 't',
			type <- thisModule.EClass2OclModelElement(s),
			bindings <- s.eStructuralFeatures
				->select(f | f.assignable)
				->collect(f | thisModule.EStructuralFeature2Binding(f))
		)
}

unique lazy rule EStructuralFeature2Binding {
	from
		s : ECORE!EStructuralFeature
	to
		t : ATL!Binding (
			propertyName <- s.name,
			value <- valueExp,
			isAssignment <- s.oclIsKindOf(ECORE!EAttribute)
		),
		valueExp : ATL!NavigationOrAttributeCallExp (
			source <- sourceExp,
			name <- s.name
		),
		sourceExp : ATL!VariableExp (
			referredVariable <- thisModule.resolveTemp(s.eContainingClass, 'EClass2Rule', 'inElement')
		)
}

unique lazy rule SingleEReference2Binding extends EStructuralFeature2Binding {
	from
		s : ECORE!EReference (s.upperBound = 1)
	to
		t : ATL!Binding (
			value <- opCallExp
		),
		opCallExp : ATL!OperationCallExp (
			source <- varExp,
			operationName <- s.eType.uniqueName.replaceAll('::', '_'),
			arguments <- Sequence{valueExp}
		),
		varExp : ATL!VariableExp (
			referredVariable <- varDecl
		),
		varDecl : ATL!VariableDeclaration (
			varName <- 'thisModule'
		),
		valueExp : ATL!NavigationOrAttributeCallExp
}

unique lazy rule ManyEReference2Binding extends EStructuralFeature2Binding {
	from
		s : ECORE!EReference (s.upperBound <> 1)
	to
		t : ATL!Binding (
			value <- itExp
		),
		itExp : ATL!IteratorExp (
			source <- valueExp,
			name <- 'collect',
			iterators <- Sequence{it},
			body <- opCallExp
		),
		it : ATL!Iterator (
			varName <- 'e'
		),
		opCallExp : ATL!OperationCallExp (
			source <- varExp,
			operationName <- s.eType.uniqueName.replaceAll('::', '_'),
			arguments <- Sequence{itVarExp}
		),
		varExp : ATL!VariableExp (
			referredVariable <- varDecl
		),
		varDecl : ATL!VariableDeclaration (
			varName <- 'thisModule'
		),
		itVarExp : ATL!VariableExp (
			referredVariable <- it
		),
		valueExp : ATL!NavigationOrAttributeCallExp
}

lazy rule EClass2OclModelElement {
	from
		s : ECORE!EClass
	to
		t : ATL!OclModelElement (
			name <- s.uniqueName,
			model <- thisModule.resolveTemp(thisModule.rootPackage, 'metaModel')
		)
}

